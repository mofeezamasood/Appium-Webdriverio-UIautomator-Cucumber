import { setAnimationState } from './commands/animation';
import { setBluetoothState, unpairAllBluetoothDevices } from './commands/bluetooth';
import { getClipboard } from './commands/clipboard';
import { setGeoLocation, getGeoLocation, refreshGeoLocationCache } from './commands/geolocation';
import { setDeviceLocale, listSupportedLocales } from './commands/locale';
import { scanMedia } from './commands/media';
import { setDataState, setWifiState } from './commands/network';
import { getNotifications, adjustNotificationsPermissions } from './commands/notifications';
import { getSmsList } from './commands/sms';
import { performEditorAction, typeUnicode } from './commands/typing';
import { makeMediaProjectionRecorder, adjustMediaProjectionServicePermissions } from './commands/media-projection';
import type { ADB } from 'appium-adb';
import type { Logger } from '@appium/logger';
export interface SettingsAppOpts {
    adb: ADB;
}
export interface SettingsAppStartupOptions {
    /** The maximum number of milliseconds to wait until the app has started */
    timeout?: number;
    /** Whether to restore the activity which was the current one before Settings startup */
    shouldRestoreCurrentApp?: boolean;
    /** Whether to forcefully restart the Settings app if it is already running */
    forceRestart?: boolean;
}
export declare class SettingsApp {
    readonly adb: ADB;
    readonly log: Logger;
    constructor(opts: SettingsAppOpts);
    /**
     * Ensures that Appium Settings helper application is running
     * and starts it if necessary
     *
     * @param opts Startup options
     * @throws {Error} If Appium Settings has failed to start
     * @returns Self instance for chaining
     */
    requireRunning(opts?: SettingsAppStartupOptions): Promise<SettingsApp>;
    /**
     * If the io.appium.settings package has running foreground service.
     *
     * @throws {Error} If the method gets an error in the adb shell execution
     * @returns Return true if the device Settings app has a service running in foreground
     */
    isRunningInForeground(): Promise<boolean>;
    /**
     * Performs broadcast and verifies the result of it
     *
     * @param args Arguments passed to the `am broadcast` command
     * @param action The exception message in case of broadcast failure
     * @param requireRunningApp Whether to run a check for a running Appium Settings app
     * @returns The broadcast output
     * @throws {Error} If the broadcast fails
     */
    checkBroadcast(args: string[], action: string, requireRunningApp?: boolean): Promise<string>;
    /**
     * Parses the output in JSON format retrieved from
     * the corresponding Appium Settings broadcast calls
     *
     * @param output The actual command output
     * @param entityName The name of the entity which is going to be parsed
     * @returns The parsed JSON object
     * @throws {Error} If the output cannot be parsed as a valid JSON
     */
    _parseJsonData(output: string, entityName: string): any;
    setAnimationState: typeof setAnimationState;
    setBluetoothState: typeof setBluetoothState;
    unpairAllBluetoothDevices: typeof unpairAllBluetoothDevices;
    getClipboard: typeof getClipboard;
    setGeoLocation: typeof setGeoLocation;
    getGeoLocation: typeof getGeoLocation;
    refreshGeoLocationCache: typeof refreshGeoLocationCache;
    listSupportedLocales: typeof listSupportedLocales;
    setDeviceLocale: typeof setDeviceLocale;
    scanMedia: typeof scanMedia;
    setDataState: typeof setDataState;
    setWifiState: typeof setWifiState;
    getNotifications: typeof getNotifications;
    adjustNotificationsPermissions: typeof adjustNotificationsPermissions;
    getSmsList: typeof getSmsList;
    performEditorAction: typeof performEditorAction;
    typeUnicode: typeof typeUnicode;
    makeMediaProjectionRecorder: typeof makeMediaProjectionRecorder;
    adjustMediaProjectionServicePermissions: typeof adjustMediaProjectionServicePermissions;
}
//# sourceMappingURL=client.d.ts.map