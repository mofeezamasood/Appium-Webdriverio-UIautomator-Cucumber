"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOsInfo = exports.getCpuType = exports.getOsName = exports.CD_VER = exports.CD_BASE_DIR = exports.CHROMEDRIVER_CHROME_MAPPING = void 0;
exports.getMostRecentChromedriver = getMostRecentChromedriver;
exports.getChromeVersion = getChromeVersion;
exports.getChromedriverDir = getChromedriverDir;
exports.getChromedriverBinaryPath = getChromedriverBinaryPath;
exports.retrieveData = retrieveData;
exports.generateLogPrefix = generateLogPrefix;
exports.convertToInt = convertToInt;
const lodash_1 = __importDefault(require("lodash"));
const support_1 = require("@appium/support");
const base_driver_1 = require("@appium/base-driver");
const path_1 = __importDefault(require("path"));
const compare_versions_1 = require("compare-versions");
const axios_1 = __importDefault(require("axios"));
const os_1 = __importDefault(require("os"));
const constants_1 = require("./constants");
const CD_EXECUTABLE_PREFIX = 'chromedriver';
const MODULE_NAME = 'appium-chromedriver';
/**
 * Calculates the path to the current module's root folder
 * @returns The full path to module root
 * @throws {Error} If the current module root folder cannot be determined
 */
const getModuleRoot = lodash_1.default.memoize(function getModuleRoot() {
    const root = support_1.node.getModuleRootSync(MODULE_NAME, __filename);
    if (!root) {
        throw new Error(`Cannot find the root folder of the ${MODULE_NAME} Node.js module`);
    }
    return root;
});
// Chromedriver version: minimum Chrome version
exports.CHROMEDRIVER_CHROME_MAPPING = require(path_1.default.join(getModuleRoot(), 'config', 'mapping.json'));
exports.CD_BASE_DIR = path_1.default.join(getModuleRoot(), 'chromedriver');
/**
 * Gets the most recent Chromedriver version from the mapping.
 * @param mapping - The Chromedriver version mapping (defaults to the static mapping).
 * @returns The most recent version string.
 * @throws {Error} If the mapping is empty.
 */
function getMostRecentChromedriver(mapping = exports.CHROMEDRIVER_CHROME_MAPPING) {
    if (lodash_1.default.isEmpty(mapping)) {
        throw new Error('Unable to get most recent Chromedriver version from empty mapping');
    }
    return lodash_1.default.last(lodash_1.default.keys(mapping).sort(compare_versions_1.compareVersions));
}
exports.CD_VER = process.env.npm_config_chromedriver_version ||
    process.env.CHROMEDRIVER_VERSION ||
    getMostRecentChromedriver();
/**
 * Gets the Chrome version for a given bundle ID using ADB.
 * @param adb - The ADB instance to use.
 * @param bundleId - The bundle ID of the Chrome/WebView app.
 * @returns The version name string, or undefined if not found.
 */
async function getChromeVersion(adb, bundleId) {
    const { versionName } = await adb.getPackageInfo(bundleId);
    return versionName;
}
/**
 * Gets the directory path for Chromedriver executables for a given OS.
 * @param osName - The OS name (defaults to the current OS).
 * @returns The full path to the Chromedriver directory.
 */
function getChromedriverDir(osName = (0, exports.getOsName)()) {
    return path_1.default.resolve(exports.CD_BASE_DIR, osName);
}
/**
 * Gets the path to the Chromedriver binary for a given OS.
 * @param osName - The OS name (defaults to the current OS).
 * @returns The full path to the Chromedriver binary.
 */
async function getChromedriverBinaryPath(osName = (0, exports.getOsName)()) {
    const rootDir = getChromedriverDir(osName);
    const pathSuffix = osName === constants_1.OS.WINDOWS ? '.exe' : '';
    const paths = await support_1.fs.glob(`${CD_EXECUTABLE_PREFIX}*${pathSuffix}`, {
        cwd: rootDir,
        absolute: true,
        nocase: true,
        nodir: true,
    });
    return lodash_1.default.isEmpty(paths)
        ? path_1.default.resolve(rootDir, `${CD_EXECUTABLE_PREFIX}${pathSuffix}`)
        : lodash_1.default.first(paths);
}
/**
 * Retrieves data from a URL using axios.
 * @param url - The URL to fetch from.
 * @param headers - Optional HTTP headers.
 * @param opts - Optional configuration (timeout, responseType).
 * @returns The response data.
 */
async function retrieveData(url, headers, opts = {}) {
    const { timeout = 5000, responseType = 'text' } = opts;
    return (await (0, axios_1.default)({
        url,
        headers,
        timeout,
        responseType,
    })).data;
}
/**
 * Gets the OS name for the current system.
 * @returns The OS name ('win', 'mac', or 'linux').
 */
exports.getOsName = lodash_1.default.memoize(function getOsName() {
    if (support_1.system.isWindows()) {
        return constants_1.OS.WINDOWS;
    }
    if (support_1.system.isMac()) {
        return constants_1.OS.MAC;
    }
    return constants_1.OS.LINUX;
});
/**
 * Gets the CPU type for the current system.
 * @returns The CPU type ('intel' or 'arm').
 */
exports.getCpuType = lodash_1.default.memoize(function getCpuType() {
    return lodash_1.default.includes(lodash_1.default.toLower(os_1.default.cpus()[0].model), 'apple') ? constants_1.CPU.ARM : constants_1.CPU.INTEL;
});
/**
 * Gets OS information including name, architecture, and CPU type.
 * @returns A promise that resolves to OS information.
 */
exports.getOsInfo = lodash_1.default.memoize(async function getOsInfo() {
    return {
        name: (0, exports.getOsName)(),
        arch: String(await support_1.system.arch()),
        cpu: (0, exports.getCpuType)(),
    };
});
// @ts-expect-error to avoid error
// TS2345: Argument of type '{}' is not assignable to parameter of type 'DriverOpts<Readonly<Record<string, Constraint>>>'
// Type '{}' is missing the following properties from type 'ServerArgs': address, allowCors, allowInsecure, basePath, and 26 more.
const getBaseDriverInstance = lodash_1.default.memoize(() => new base_driver_1.BaseDriver({}, false));
/**
 * Generates log prefix string.
 * @param obj - Log owner instance.
 * @param sessionId - Optional session identifier.
 * @returns The generated log prefix string.
 */
function generateLogPrefix(obj, sessionId = null) {
    return getBaseDriverInstance().helpers.generateDriverLogPrefix(obj, sessionId ? sessionId : undefined);
}
/**
 * Converts the given object to an integer number if possible.
 * @param value - The value to be converted.
 * @returns The integer value or null if conversion is not possible.
 */
function convertToInt(value) {
    switch (typeof value) {
        case 'number':
            return Number.isNaN(value) ? null : value;
        case 'string': {
            const parsedAsInt = parseInt(value, 10);
            return Number.isNaN(parsedAsInt) ? null : parsedAsInt;
        }
        default:
            return null;
    }
}
//# sourceMappingURL=utils.js.map