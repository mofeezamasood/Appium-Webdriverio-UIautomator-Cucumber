import events from 'events';
import { JWProxy } from '@appium/base-driver';
import type { HTTPMethod, HTTPBody } from '@appium/types';
import type { Request, Response } from 'express';
import type { ChromedriverOpts } from './types';
type SessionCapabilities = Record<string, any>;
export declare class Chromedriver extends events.EventEmitter {
    static readonly EVENT_ERROR = "chromedriver_error";
    static readonly EVENT_CHANGED = "stateChanged";
    static readonly STATE_STOPPED = "stopped";
    static readonly STATE_STARTING = "starting";
    static readonly STATE_ONLINE = "online";
    static readonly STATE_STOPPING = "stopping";
    static readonly STATE_RESTARTING = "restarting";
    private readonly _log;
    private readonly proxyHost;
    private readonly proxyPort;
    private readonly adb?;
    private readonly cmdArgs?;
    private proc;
    private readonly useSystemExecutable;
    private chromedriver?;
    private readonly executableDir;
    private readonly mappingPath?;
    private bundleId?;
    private executableVerified;
    state: string;
    private readonly _execFunc;
    jwproxy: JWProxy;
    private readonly isCustomExecutableDir;
    private readonly verbose?;
    private readonly logPath?;
    private readonly disableBuildCheck;
    private readonly storageClient;
    private readonly details?;
    private capabilities;
    private _desiredProtocol;
    private _driverVersion;
    private _onlineStatus;
    constructor(args?: ChromedriverOpts);
    /**
     * Gets the logger instance for this Chromedriver instance.
     * @returns The logger instance.
     */
    get log(): any;
    /**
     * Gets the version of the currently running Chromedriver.
     * @returns The driver version string, or null if not yet determined.
     */
    get driverVersion(): string | null;
    /**
     * Starts a new Chromedriver session with the given capabilities.
     * @param caps - The session capabilities to use.
     * @param emitStartingState - Whether to emit the starting state event (default: true).
     * @returns A promise that resolves to the session capabilities returned by Chromedriver.
     * @throws {Error} If Chromedriver fails to start or crashes during startup.
     */
    start(caps: SessionCapabilities, emitStartingState?: boolean): Promise<SessionCapabilities>;
    /**
     * Gets the current session ID if the driver is online.
     * @returns The session ID string, or null if the driver is not online.
     */
    sessionId(): string | null;
    /**
     * Restarts the Chromedriver session.
     * The session will be stopped and then started again with the same capabilities.
     * @returns A promise that resolves to the session capabilities returned by Chromedriver.
     * @throws {Error} If the driver is not online or if restart fails.
     */
    restart(): Promise<SessionCapabilities>;
    /**
     * Stops the Chromedriver session and terminates the process.
     * @param emitStates - Whether to emit state change events during shutdown (default: true).
     * @returns A promise that resolves when the session has been stopped.
     */
    stop(emitStates?: boolean): Promise<void>;
    /**
     * Sends a command to the Chromedriver server.
     * @param url - The endpoint URL (e.g., '/url', '/session').
     * @param method - The HTTP method to use ('POST', 'GET', or 'DELETE').
     * @param body - Optional request body for POST requests.
     * @returns A promise that resolves to the response from Chromedriver.
     */
    sendCommand(url: string, method: HTTPMethod, body?: HTTPBody): Promise<HTTPBody>;
    /**
     * Proxies an HTTP request/response to the Chromedriver server.
     * @param req - The incoming HTTP request object.
     * @param res - The outgoing HTTP response object.
     * @returns A promise that resolves when the proxying is complete.
     */
    proxyReq(req: Request, res: Response): Promise<void>;
    /**
     * Checks if Chromedriver is currently able to automate webviews.
     * Sometimes Chromedriver stops automating webviews; this method runs a simple
     * command to determine the current state.
     * @returns A promise that resolves to true if webviews are working, false otherwise.
     */
    hasWorkingWebview(): Promise<boolean>;
    private buildChromedriverArgs;
    private getDriversMapping;
    private getChromedrivers;
    private getChromeVersion;
    private updateDriversMapping;
    private getCompatibleChromedriver;
    private initChromedriverPath;
    private syncProtocol;
    private waitForOnline;
    private getStatus;
    private startSession;
    private changeState;
    private killAll;
}
export {};
//# sourceMappingURL=chromedriver.d.ts.map